// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.IO;
using BuildXL.Engine.Cache.Serialization;
using BuildXL.Pips.Builders;
using BuildXL.Pips.Operations;
using BuildXL.Scheduler;
using BuildXL.Scheduler.Fingerprints;
using BuildXL.Scheduler.Tracing;
using BuildXL.Utilities;
using BuildXL.Utilities.Tracing;
using BuildXL.Utilities.Configuration;
using Test.BuildXL.Executables.TestProcess;
using Test.BuildXL.Scheduler;
using Test.BuildXL.TestUtilities.Xunit;
using BuildXL.Execution.Analyzer;
using Xunit;
using Xunit.Abstractions;
using static BuildXL.ToolSupport.CommandLineUtilities;
using static Test.Tool.Analyzers.AnalyzerTestBase;
using BuildXLConfiguration = BuildXL.Utilities.Configuration;
using System;
using static BuildXL.Scheduler.Tracing.FingerprintStore;
using System.Linq;

namespace Test.Tool.Analyzers
{
    /// <summary>
    /// Tests for <see cref="FingerprintStoreAnalyzer"/>.
    /// The construction and disposal of these tests rely on the fact that 
    /// Xunit uses a unique class instance for each test.
    /// /// </summary>
    public class FingerprintStoreAnalyzerTests : AnalyzerTestBase
    {
        public FingerprintStoreAnalyzerTests(ITestOutputHelper output) : base(output)
        {
            Configuration.Logging.CacheMissAnalysisOption = BuildXLConfiguration.CacheMissAnalysisOption.LocalMode();
            Configuration.Logging.StoreFingerprints = true;
            AnalysisMode = AnalysisMode.CacheMiss;

            string outputDirectory = Path.Combine(TemporaryDirectory, "cachemiss");
            // Set the result file to the file generated by cache miss analyzer
            ResultFileToRead = Path.Combine(outputDirectory, CacheMissAnalyzer.AnalysisFileName);
            
            ModeSpecificDefaultArgs = new Option[]
            {
                new Option
                {
                    Name = "outputDirectory",
                    Value = outputDirectory
                }
            };

            CacheMissAnalyzerResultExtensions.FingerprintStoreAnalyzerTestsClass = this;
        }

        [Fact]
        public void SourceFileWeakFingerprintMiss()
        {
            FileArtifact srcFile = CreateSourceFile();
            Process pip = CreateAndSchedulePipBuilder(new Operation[]
            {
                Operation.ReadFile(srcFile),
                Operation.WriteFile(CreateOutputFileArtifact())
            }).Process;

            RunScheduler().AssertCacheMiss(pip.PipId);
            
            ScheduleRunResult cacheHitBuild = RunScheduler().AssertCacheHit(pip.PipId);

            // Modify file to create weak fingerprint miss
            File.WriteAllText(ArtifactToPrint(srcFile), "asdf");

            ScheduleRunResult cacheMissBuild = RunScheduler().AssertCacheMiss(pip.PipId);

            string[] messages = { ArtifactToPrint(srcFile) };

            RunAnalyzer(cacheHitBuild, cacheMissBuild).AssertPipMiss(pip, PipCacheMissType.MissForDescriptorsDueToWeakFingerprints, messages);
        }

        [Fact]
        public virtual void AbsentFileProbeReadOnlyMountStrongFingerprintMiss()
        {
            // Read only mount
            var sealDir = CreateUniqueDirectory(ReadonlyRoot);
            // Set up absent file under source seal directory
            var absentFile = CreateSourceFile(sealDir);
            File.Delete(ArtifactToString(absentFile));
            var absentFileDir = CreateAndScheduleSealDirectoryArtifact(sealDir, SealDirectoryKind.SourceAllDirectories);

            // Pip probes absent input and directory
            var ops = new Operation[]
            {
                Operation.Probe(absentFile, doNotInfer: true),
                Operation.WriteFile(CreateOutputFileArtifact())
            };

            var builder = CreatePipBuilder(ops);
            builder.AddInputDirectory(absentFileDir);

            Process pip = SchedulePipBuilder(builder).Process;

            var build1 = RunScheduler().AssertCacheMiss(pip.PipId);

            // Create /absentFile
            File.WriteAllText(ArtifactToString(absentFile), "asdf");
            var build2 = RunScheduler().AssertCacheMiss(pip.PipId);

            RunAnalyzer(build1, build2).AssertPipMiss(
                pip, 
                PipCacheMissType.MissForDescriptorsDueToStrongFingerprints,
                ArtifactToPrint(absentFile),
                ObservedInputConstants.AbsentPathProbe,
                ObservedInputConstants.FileContentRead);
        }

        [Fact]
        public void DirectoryEnumerationReadOnlyMountStrongFingerprintMiss()
        {
            string[] messages;
            DirectoryArtifact dir = DirectoryArtifact.CreateWithZeroPartialSealId(CreateUniqueDirectory(ReadonlyRoot));
            Directory.CreateDirectory(ArtifactToPrint(dir));

            Process pip = CreateAndSchedulePipBuilder(new Operation[]
            {
                Operation.EnumerateDir(dir),
                Operation.WriteFile(CreateOutputFileArtifact())
            }).Process;

            RunScheduler().AssertCacheMiss(pip.PipId);
            
            ScheduleRunResult buildA = RunScheduler().AssertCacheHit(pip.PipId);

            // Strong fingerprint miss: AbsentPathProbe => DirectoryEnumeration
            // (empty directory enumeration conflates to absent path probe)
            FileArtifact nestedFile = CreateSourceFile(ArtifactToPrint(dir));
            ScheduleRunResult buildB = RunScheduler().AssertCacheMiss(pip.PipId);

            messages = new string[] { ArtifactToPrint(dir), ObservedInputType.AbsentPathProbe.ToString(), ObservedInputType.DirectoryEnumeration.ToString() };

            RunAnalyzer(buildA, buildB).AssertPipMiss(pip, PipCacheMissType.MissForDescriptorsDueToStrongFingerprints, messages);

            // Strong fingerprint miss: Added new files to enumerated directory
            FileArtifact addedFile = CreateSourceFile(ArtifactToPrint(dir));
            FileArtifact victimFile = CreateSourceFile(ArtifactToPrint(dir));
            ScheduleRunResult buildC = RunScheduler().AssertCacheMiss(pip.PipId);

            messages = new string[] { ArtifactToPrint(dir), Path.GetFileName(ArtifactToPrint(addedFile)), Path.GetFileName(ArtifactToPrint(victimFile)) };

            RunAnalyzer(buildB, buildC).AssertPipMiss(pip, PipCacheMissType.MissForDescriptorsDueToStrongFingerprints, messages);

            // Strong fingerprint miss: Deleted file in enumerated directory
            File.Delete(ArtifactToPrint(victimFile));
            ScheduleRunResult buildD = RunScheduler().AssertCacheMiss(pip.PipId);

            messages = new string[] { ArtifactToPrint(dir), Path.GetFileName(ArtifactToPrint(victimFile)) };
            
            RunAnalyzer(buildC, buildD).AssertPipMiss(
                pip,
                PipCacheMissType.MissForDescriptorsDueToStrongFingerprints,
                messages);;
        }

        [Fact]
        public void NonCacheableWhitelistPipMiss()
        {
            FileArtifact whitelistFile = CreateSourceFile();
            var entry = new BuildXLConfiguration.Mutable.FileAccessWhitelistEntry()
            {
                Value = "testValue",
                PathFragment = ArtifactToString(whitelistFile),
            };
            Configuration.FileAccessWhiteList.Add(entry);

            Process pip = CreateAndSchedulePipBuilder(new Operation[]
            {
                Operation.ReadFile(whitelistFile, doNotInfer: true),
                Operation.WriteFile(CreateOutputFileArtifact())
            }).Process;

            ScheduleRunResult buildA = RunScheduler().AssertCacheMiss(pip.PipId);
            
            ScheduleRunResult buildB = RunScheduler().AssertCacheMiss(pip.PipId);
            var messages = new string[] { "disallowed file accesses", PipCacheMissType.MissForDescriptorsDueToWeakFingerprints.ToString() };
            
            RunAnalyzer(buildA, buildB).AssertPipMiss(
                pip,
                PipCacheMissType.MissForDescriptorsDueToWeakFingerprints,
                messages);
        }

        [Fact]
        public void FileAccessViolationUncacheablePipMiss()
        {
            Configuration.Sandbox.UnsafeSandboxConfigurationMutable.UnexpectedFileAccessesAreErrors = false;

            FileArtifact unexpectedFile = CreateSourceFile();
            Process pip = CreateAndSchedulePipBuilder(new Operation[]
            {
                Operation.WriteFile(CreateOutputFileArtifact()),
                Operation.ReadFile(unexpectedFile, doNotInfer: true)
            }).Process;

            ScheduleRunResult buildA = RunScheduler().AssertCacheMiss(pip.PipId);
            
            // Pip allowed to run successfully, but will not be cached due to file monitoring violations
            ScheduleRunResult buildB = RunScheduler().AssertCacheMiss(pip.PipId);
            var messages = new string[] { "disallowed file accesses", PipCacheMissType.MissForDescriptorsDueToWeakFingerprints.ToString() };
            
            RunAnalyzer(buildA, buildB).AssertPipMiss(
                pip,
                PipCacheMissType.MissForDescriptorsDueToWeakFingerprints,
                messages);
        }

        /// <summary>
        /// Only analyze pips downstream of an already-analyzed pip miss if /allPips option is specified.
        /// </summary>
        /// <note>
        /// This prevents analysis of any downstream pips, even if they
        /// had a cache miss cause other than the upstream pip being executed.
        /// </note>
        [Fact]
        public void TestAllPipsOption()
        {
            FileArtifact srcA = CreateSourceFile();
            FileArtifact outA = CreateOutputFileArtifact();
            Process pipA = CreateAndSchedulePipBuilder(new Operation[]
            {
                Operation.ReadFile(srcA),
                Operation.WriteFile(outA)
            }).Process;

            // Make pipB dependent on pipA
            FileArtifact srcB = CreateSourceFile();
            Process pipB = CreateAndSchedulePipBuilder(new Operation[]
            {
                Operation.ReadFile(srcB),
                Operation.ReadFile(outA),
                Operation.WriteFile(CreateOutputFileArtifact())
            }).Process;

            RunScheduler().AssertCacheMiss(pipA.PipId, pipB.PipId);
            
            ScheduleRunResult buildA = RunScheduler().AssertCacheHit(pipA.PipId, pipB.PipId);

            // Force miss on pipA
            File.WriteAllText(ArtifactToPrint(srcA), "asdf");
            // Force miss on pipB
            File.WriteAllText(ArtifactToPrint(srcB), "hjkl");

            ScheduleRunResult buildB = RunScheduler().AssertCacheMiss(pipA.PipId, pipB.PipId);

            AnalyzerResult result = RunAnalyzer(buildA, buildB);
            result.AssertPipMiss(
                pipA,
                PipCacheMissType.MissForDescriptorsDueToWeakFingerprints,
                ArtifactToPrint(srcA));

            // Don't analyze downstream pip misses
            XAssert.IsFalse(result.FileOutput.Contains(pipB.FormattedSemiStableHash));

            Option allPips = new Option
            {
                Name = "allPips",
            };

            AnalyzerResult allPipsResult = RunAnalyzer(buildA, buildB, additionalArgs: new Option[] { allPips });
            allPipsResult.AssertPipMiss(
                pipA,
                PipCacheMissType.MissForDescriptorsDueToWeakFingerprints,
                ArtifactToPrint(srcA));
            // Analyze downstream pips, runtime cache miss does not have an all pips option
            allPipsResult.AssertAnalyzerPipMiss(
                pipA,
                PipCacheMissType.MissForDescriptorsDueToWeakFingerprints,
                ArtifactToPrint(srcB));
        }

        [Fact]
        public void FilterSkippedPipNoFingerprint()
        {
            FileArtifact src = CreateSourceFile();

            var pipBuilderA = this.CreatePipBuilder(new Operation[]
            {
                Operation.ReadFile(src),
                Operation.WriteFile(CreateOutputFileArtifact())
            });
            pipBuilderA.AddTags(Context.StringTable, "pipA");
            Process pipA = SchedulePipBuilder(pipBuilderA).Process;

            // Create independent pipB
            var pipBuilderB = this.CreatePipBuilder(new Operation[]
            {
                Operation.ReadFile(src),
                Operation.WriteFile(CreateOutputFileArtifact())
            });
            pipBuilderB.AddTags(Context.StringTable, "pipB");
            Process pipB = SchedulePipBuilder(pipBuilderB).Process;

            RunScheduler().AssertCacheMiss(pipA.PipId, pipB.PipId);
            
            Configuration.Filter = "tag='pipB'"; // filter graph to just pipB

            var buildA = RunScheduler().AssertCacheHit(pipB.PipId);

            Configuration.Filter = ""; // reset filter to default

            // Cause a miss on pipA and pipB
            File.WriteAllText(ArtifactToPrint(src), "asdf");
            var buildB = RunScheduler().AssertCacheMiss(pipA.PipId, pipB.PipId);

            var messages = new string[] { ArtifactToPrint(src) };
            
            AnalyzerResult result = RunAnalyzer(buildA, buildB);
            // Missing fingerprint for pipA because it was filtered out in last build
            result.AssertPipMiss(
                pipA,
                PipCacheMissType.MissForDescriptorsDueToWeakFingerprints,
                messages);

            // Normal analysis for pipB
            result.AssertPipMiss(
                pipB,
                PipCacheMissType.MissForDescriptorsDueToWeakFingerprints,
                messages);
        }

        [Fact]
        public void CommandLineChangeCacheMiss()
        {
            var outFile = CreateOutputFileArtifact();
            var outOp = Operation.WriteFile(outFile, "hello.txt");
            var pip = CreateAndSchedulePipBuilder(new Operation[]
            {
                outOp
            }).Process;

            RunScheduler().AssertCacheMiss(pip.PipId);
            
            // Reset the graph and re-schedule the same pip to verify
            // the generating pip Ids is stable across graphs and gets a cache hit
            ResetPipGraphBuilder();

            var repeatPip = CreateAndSchedulePipBuilder(new Operation[]
            {
                outOp
            }).Process;

            XAssert.AreEqual(pip.PipId, repeatPip.PipId);
            var buildA = RunScheduler().AssertCacheHit(repeatPip.PipId);

            // Reset the graph and re-schedule the same pip but with an added command line arg
            ResetPipGraphBuilder();

            var mismatchingPipBuilder = CreatePipBuilder(new Operation[]
            {
                outOp
            });

            // Adds an argument to the test process' command line that won't crash the test process 
            // and won't cause disallowed file access
            var nonExistentDir = CreateOutputDirectoryArtifact();
            mismatchingPipBuilder.ArgumentsBuilder.Add(Operation.EnumerateDir(nonExistentDir).ToCommandLine(Context.PathTable));

            var mismatchingPip = SchedulePipBuilder(mismatchingPipBuilder).Process;

            // Make sure the new argument didn't churn the pip id
            XAssert.AreEqual(pip.PipId, mismatchingPip.PipId);
            var buildB = RunScheduler().AssertCacheMiss(mismatchingPip.PipId);

            var messages = new string[] { "Arguments" };
            
            AnalyzerResult result = RunAnalyzer(buildA, buildB).AssertPipMiss(
                mismatchingPip,
                PipCacheMissType.MissForDescriptorsDueToWeakFingerprints,
                messages);
        }

        [Fact]
        public void DirectoryMembershipFingerprintMissing()
        {
            DirectoryArtifact dir = DirectoryArtifact.CreateWithZeroPartialSealId(CreateUniqueDirectory(ReadonlyRoot));
            Directory.CreateDirectory(ArtifactToPrint(dir));

            Process pip = CreateAndSchedulePipBuilder(new Operation[]
            {
                Operation.EnumerateDir(dir),
                Operation.WriteFile(CreateOutputFileArtifact())
            }).Process;

            RunScheduler().AssertCacheMiss(pip.PipId);
            ScheduleRunResult buildA = RunScheduler().AssertCacheHit(pip.PipId);

            // Strong fingerprint miss: AbsentPathProbe => DirectoryEnumeration
            // (empty directory enumeration conflates to absent path probe)
            FileArtifact nestedFile = CreateSourceFile(ArtifactToPrint(dir));
            ScheduleRunResult buildB = RunScheduler().AssertCacheMiss(pip.PipId);

            // On a strong fingerprint miss, both the execution and cache lookup store will store fingerprints
            using (var executionStore = FingerprintStore.Open(ResultToStoreDirectory(buildB)).Result)
            using (var cacheLookupStore = FingerprintStore.Open(ResultToStoreDirectory(buildB, cacheLookupStore: true)).Result)
            {
                XAssert.IsTrue(executionStore.TryGetFingerprintStoreEntryBySemiStableHash(pip.FormattedSemiStableHash, out var entry));
                XAssert.IsTrue(cacheLookupStore.TryGetFingerprintStoreEntryBySemiStableHash(pip.FormattedSemiStableHash, out var cacheLookupEntry));

                // Parse the entry for the directory membership fingerprint key
                var reader = new JsonReader(entry.StrongFingerprintEntry.StrongFingerprintToInputs.Value);
                XAssert.IsTrue(reader.TryGetPropertyValue(ObservedInputConstants.DirectoryEnumeration, out string directoryMembershipFingerprint));

                // Remove the directory memberhsip entry
                executionStore.RemoveContentHashForTesting(directoryMembershipFingerprint);
                cacheLookupStore.RemoveContentHashForTesting(directoryMembershipFingerprint);
            }

            var result = RunAnalyzer(buildA, buildB).AssertPipMiss(
                pip,
                PipCacheMissType.MissForDescriptorsDueToStrongFingerprints,
                ArtifactToPrint(dir),
                ObservedInputType.AbsentPathProbe.ToString(),
                ObservedInputType.DirectoryEnumeration.ToString());
        }

        /// <summary>
        /// If pip can have a fingerprint cache hit, but still need to be executed due to failures in the previous build (or any
        /// other settings that might prevent caching the pip's outputs). There will be no difference in fingerprint content,
        /// but the cache miss analyzer should still print something for the miss analysis.
        /// </summary>
        [Fact]
        public void MissDueToFailedPipInPreviousBuildHasAnalysisOutput()
        {
            // Failed pips still report their full fingerprint content and observed inputs to the fingerprint store (and XLG in general)
            var failPip = CreateAndSchedulePipBuilder(new Operation[]
            {
                Operation.WriteFile(CreateOutputFileArtifact()),
                Operation.Fail(),
            }).Process;

            // Both builds will fail to cache any output to the cache due to the pip failure
            var buildA = RunScheduler().AssertFailure();
            var buildB = RunScheduler().AssertFailure();
            AssertErrorEventLogged(EventId.PipProcessError, 2);

            // buildB has a cache miss for failPip due to no content being stored in buildA,
            // however their fingerprints match since they are the same pip and fail after the same set of filesystem operations in both runs
            RunAnalyzer(buildA, buildB).AssertPipMiss(
                failPip,
                PipCacheMissType.MissForDescriptorsDueToWeakFingerprints,
                CacheMissAnalysisUtilities.RepeatedStrings.DisallowedFileAccessesOrPipFailuresPreventCaching);
        }

        /// <summary>
        /// The fingerprint store uniquely identifies pips by a hash of their first declared output (pip unique output hash).
        /// The pip unique output hash is more stable the the pip semi stable hash, so the pip unique output hash is used for look up first
        /// before falling back on the pip semi stable hash.
        /// </summary>
        [Fact] 
        public void VerifyStablePipUniqueOutputHash()
        {
            var outputFile = CreateOutputFileArtifact();

            var dir = DirectoryArtifact.CreateWithZeroPartialSealId(CreateUniqueDirectory(ReadonlyRoot));
            var nestedFile = CreateSourceFile(ArtifactToPrint(dir));

            var opaqueDir = DirectoryArtifact.CreateWithZeroPartialSealId(CreateUniqueDirectory(ObjectRoot));
            var nestedOpaqueFile = CreateOutputFileArtifact(ArtifactToPrint(opaqueDir));
            var srcFile = CreateSourceFile();

            // Control the working directory for each pip so it doesn't cause weak fingerprint misses
            var stableWorkingDirectory = DirectoryArtifact.CreateWithZeroPartialSealId(CreateUniqueDirectory());

            // Control the temp directory for some pips so it doesn't cause weak fingerprint misses
            var stableTempDirectory1 = DirectoryArtifact.CreateWithZeroPartialSealId(CreateUniqueDirectory());

            // Schedule a pip that creates outputFile
            var outputFileProducerOps = new Operation[]
            {
                Operation.EnumerateDir(dir),
                Operation.WriteFile(outputFile)
            };
            var outputFileProducerBuilder = CreatePipBuilder(outputFileProducerOps);
            outputFileProducerBuilder.WorkingDirectory = stableWorkingDirectory;
            outputFileProducerBuilder.SetTempDirectory(stableTempDirectory1);

            var outputFilePip = SchedulePipBuilder(outputFileProducerBuilder).Process;

            // Schedule a pip that creates opaqueDir
            var opaqueDirProducerOps = new Operation[]
            {
                Operation.ReadFile(srcFile),
                Operation.CreateDir(opaqueDir),
                Operation.WriteFile(nestedOpaqueFile, "nestedOpaqueFile"),
            };

            // Schedule a pip that creates opaqueDirectory
            var opaqueDirProducerBuilder = CreatePipBuilder(opaqueDirProducerOps);
            opaqueDirProducerBuilder.WorkingDirectory = stableWorkingDirectory;

            var opaqueDirPip = SchedulePipBuilder(opaqueDirProducerBuilder).Process;

            // Run first build
            var build1 = RunScheduler().AssertCacheMiss(outputFilePip.PipId, opaqueDirPip.PipId);
            
            // Reset the pip graph to schedule new pips
            ResetPipGraphBuilder();

            // Schedule a random pip that does not create output
            // This will match with pipA which happens to have the same formatted semistable hash
            var randomPipBuilder = CreatePipBuilder(new Operation[]
            {
                Operation.WriteFile(CreateOutputFileArtifact())
            });
            randomPipBuilder.WorkingDirectory = stableWorkingDirectory;
            var randomPip = SchedulePipBuilder(randomPipBuilder).Process;

            // Cause a strong fingerprint miss for outputFilePip
            var enumeratedNestedFile = CreateSourceFile(ArtifactToPrint(dir));
            // Cause a weak fingerprint miss for opaqueDirPip
            File.WriteAllText(ArtifactToPrint(srcFile), "miss");

            // Schedule a pip that creates outputFile to match unique output hashes with outputFilePip which also created outputFile
            outputFileProducerBuilder = CreatePipBuilder(outputFileProducerOps);
            outputFileProducerBuilder.WorkingDirectory = stableWorkingDirectory;
            outputFileProducerBuilder.SetTempDirectory(stableTempDirectory1);
            var outputFilePip2 = SchedulePipBuilder(outputFileProducerBuilder).Process;

            // Schedule a pip that creates opaqueDir to match unique output hashes with opaqueDirPip which also created opaqueDir
            opaqueDirProducerBuilder = CreatePipBuilder(opaqueDirProducerOps);
            opaqueDirProducerBuilder.WorkingDirectory = stableWorkingDirectory;
            var opaqueDirPip2 = SchedulePipBuilder(opaqueDirProducerBuilder).Process;

            // Add a pip that rewrites outputFile to make sure that the unique output hash is different from outputFilePip2
            var rewrittenFileBuilder = CreatePipBuilder(new Operation[]
            {
                Operation.WriteFile(outputFile, doNotInfer: true) // Write the file, but declare it as a rewritten file
            });

            rewrittenFileBuilder.AddRewrittenFileInPlace(outputFile);
            var rewrittenFilePip = SchedulePipBuilder(rewrittenFileBuilder).Process;

            // Run second build
            var build2 = RunScheduler().AssertCacheMiss(randomPip.PipId, outputFilePip2.PipId, rewrittenFilePip.PipId);

            Option allPips = new Option
            {
                Name = "allPips",
            };

            // Run cache miss analyzer
            var result = RunAnalyzer(build1, build2, additionalArgs: new Option[] { allPips });
            // These pips happen to have the same semi stable hash because of the order
            // they were scheduled in, but conceptually they are unrelated
            XAssert.AreEqual(outputFilePip.FormattedSemiStableHash, randomPip.FormattedSemiStableHash);

            // When no unique output hash is available for a pip, the cache miss analyzer falls back on pip semi stable hash.
            // This will match outputFilePip with randomPip which is essentially nonsensical because they are unrelated pips.
            result.AssertPipMiss(
                randomPip,
                PipCacheMissType.MissForDescriptorsDueToWeakFingerprints);

            // These pips have different semi stable hashes because of the order they were
            // scheduled in, but are conceptually the same because they generate the same output
            XAssert.AreNotEqual(outputFilePip.FormattedSemiStableHash, outputFilePip2.FormattedSemiStableHash);
            XAssert.AreNotEqual(opaqueDirPip.FormattedSemiStableHash, opaqueDirPip2.FormattedSemiStableHash);

            // Strong fingerprint miss due to nestedFile2 being enumerated
            // outputFilePip2 should have matched with outputFilePip by unique output hash, even though they have different semi stable hashes
            result.AssertPipMiss(
                outputFilePip2,
                PipCacheMissType.MissForDescriptorsDueToStrongFingerprints,
                CacheMissAnalysisUtilities.RepeatedStrings.FormattedSemiStableHashChanged,
                outputFilePip.FormattedSemiStableHash,
                outputFilePip2.FormattedSemiStableHash,
                Path.GetFileName(ArtifactToPrint(enumeratedNestedFile)));

            // Weak fingerprint miss due to srcFile being changed
            // opaqueDirPip2 should have matched with opaqueDirPip by unique output hash, even though they have different semi stable hashes
            result.AssertPipMiss(
                opaqueDirPip2,
                PipCacheMissType.MissForDescriptorsDueToWeakFingerprints,
                CacheMissAnalysisUtilities.RepeatedStrings.FormattedSemiStableHashChanged,
                opaqueDirPip.FormattedSemiStableHash,
                opaqueDirPip2.FormattedSemiStableHash,
                ArtifactToPrint(srcFile));

            // Make sure pips that produce the same output but different rewrite counts are excluded
            XAssert.AreNotEqual(outputFilePip2.FormattedSemiStableHash, rewrittenFilePip.FormattedSemiStableHash);

            // As long as the rewrite count is being included in the pip output hash, rewrittenFilePIp should not have any information from build1
            result.AssertPipMiss(
                rewrittenFilePip,
                PipCacheMissType.MissForDescriptorsDueToWeakFingerprints,
                "No fingerprint computation data found from old build");
        }

        [Fact]
        public void NoFingerprintFoundFromBuild()
        {
            var outFile = CreateOutputFileArtifact();
            var pip = CreateAndSchedulePipBuilder(new Operation[]
            {
                Operation.WriteFile(outFile)
            }).Process;

            var build1 = RunScheduler().AssertSuccess();

            ResetPipGraphBuilder();

            pip = CreateAndSchedulePipBuilder(new Operation[]
            {
                Operation.WriteFile(outFile)
            }).Process;

            var newPip = CreateAndSchedulePipBuilderWithArbitraryOutput().Process;

            var build2 = RunScheduler().AssertCacheMiss(newPip.PipId);
            var result = RunAnalyzer(build1, build2);

            result.AssertPipMiss(
                newPip,
                PipCacheMissType.MissForDescriptorsDueToWeakFingerprints,
                "No fingerprint computation data found from old build"
                );
        }


        [FactIfSupported(requiresJournalScan: true)]
        public void IncrementalSchedulingSkippedPipNoFingerprint()
        {
            Configuration.Schedule.IncrementalScheduling = true;
            Configuration.Schedule.SkipHashSourceFile = false;

            FileArtifact src = CreateSourceFile();
            Process pip = CreateAndSchedulePipBuilder(new Operation[]
            {
                Operation.ReadFile(src),
                Operation.WriteFile(CreateOutputFileArtifact())
            }).Process;

            RunScheduler().AssertCacheMiss(pip.PipId);

            // Incremental scheduling will skip executing clean pip
            var buildA = RunScheduler().AssertCacheHit(pip.PipId);

            File.WriteAllText(ArtifactToPrint(src), "asfd");
            var buildB = RunScheduler().AssertCacheMiss(pip.PipId);

            var messages = new string[] { ArtifactToPrint(src) };

            AnalyzerResult result = RunAnalyzer(buildA, buildB);

            // The pip is in the old graph, but there is no weak fingerprint computation
            // to compare to since it was skipped in the last build
            result.AssertPipMiss(
                pip,
                PipCacheMissType.MissForDescriptorsDueToWeakFingerprints,
                messages);
        }

        [Fact]
        public void TestUnsafeConfigurationDiffsCorrectly()
        {
            Configuration.Sandbox.UnsafeSandboxConfigurationMutable.UnexpectedFileAccessesAreErrors = !UnsafeOptions.SafeConfigurationValues.UnexpectedFileAccessesAreErrors;

            var pip = CreateAndSchedulePipBuilder(new Operation[]
            {
                Operation.WriteFile(CreateOutputFileArtifact())
            }).Process;

            var build1 = RunScheduler().AssertCacheMiss(pip.PipId);

            // Go from unsafe -> safe to cause cache miss (it's possible to get a hit on different, but safer configurations)
            Configuration.Sandbox.UnsafeSandboxConfigurationMutable.UnexpectedFileAccessesAreErrors = UnsafeOptions.SafeConfigurationValues.UnexpectedFileAccessesAreErrors;

            var build2 = RunScheduler().AssertCacheMiss(pip.PipId);

            var result = RunAnalyzer(build1, build2);

            result.AssertPipMiss(
                pip,
                PipCacheMissType.MissForDescriptorsDueToStrongFingerprints,
                "UnsafeOptions");
        }

        /// <summary>
        /// Checks that <see cref="FingerprintStoreExecutionLogTarget.CacheLookupFingerprintStore"/> is used before the <see cref="FingerprintStoreExecutionLogTarget.ExecutionFingerprintStore"/>
        /// when looking for fingerprints from the newer build.
        /// </summary>
        [Fact]
        public void EnsureCacheLookupStoreIsFirst()
        {
            // Read only mount
            var sealDir = CreateUniqueDirectory(ReadonlyRoot);
            // Set up absent file under source seal directory
            var absentFile = CreateSourceFile(sealDir);
            File.Delete(ArtifactToString(absentFile));
            var absentFileDir = CreateAndScheduleSealDirectoryArtifact(sealDir, SealDirectoryKind.SourceAllDirectories);

            // Create a pip that will have a strong fingerprint miss if absentFile is created
            var ops = new Operation[]
            {
                Operation.Probe(absentFile, doNotInfer: true),
                Operation.WriteFile(CreateOutputFileArtifact())
            };

            var builder = CreatePipBuilder(ops);
            builder.AddInputDirectory(absentFileDir);

            var pipA = SchedulePipBuilder(builder).Process;

            var srcB = CreateSourceFile();
            var pipB = CreateAndSchedulePipBuilder(new Operation[]
            {
                Operation.ReadFile(srcB),
                Operation.WriteFile(CreateOutputFileArtifact())
            }).Process;

            var build1 = RunScheduler().AssertCacheMiss(pipA.PipId);

            // Create /absentFile
            File.WriteAllText(ArtifactToString(absentFile), "asdf");
            var build2 = RunScheduler().AssertCacheMiss(pipA.PipId);

            var correctOut1 = RunAnalyzer(build1, build2).AssertPipMiss(
                pipA,
                PipCacheMissType.MissForDescriptorsDueToStrongFingerprints,
                ArtifactToPrint(absentFile),
                ObservedInputConstants.AbsentPathProbe,
                ObservedInputConstants.FileContentRead).FileOutput;

            FingerprintStoreEntry pipAEntry = default;
            FingerprintStoreSession(ResultToStoreDirectory(build2), store =>
            {
                // Remove pipA's entry from the execution-time fingerprintStore, and replace it with a dummy entry (pipB's) that will diff incorrectly if used
                store.TryGetFingerprintStoreEntryBySemiStableHash(pipA.FormattedSemiStableHash, out pipAEntry);
                store.RemoveFingerprintStoreEntryForTesting(pipAEntry);

                store.TryGetFingerprintStoreEntryBySemiStableHash(pipB.FormattedSemiStableHash, out var pipBEntry);
                // Route's pipA's key to point to the same fingerprint info as pipB's
                // If this store is used now to analyze pipA, the analysis will be incorrect
                pipBEntry.PipToFingerprintKeys = new System.Collections.Generic.KeyValuePair<string, PipFingerprintKeys>(pipA.FormattedSemiStableHash, pipBEntry.PipToFingerprintKeys.Value);
                store.PutFingerprintStoreEntry(pipBEntry);
            },
            readOnly: false);

            // Make sure the diff is still correct, which implies the cache lookup fingerprint store is still being used
            var correctOut2 = RunAnalyzer(build1, build2).AssertPipMiss(
                pipA,
                PipCacheMissType.MissForDescriptorsDueToStrongFingerprints,
                ArtifactToPrint(absentFile),
                ObservedInputConstants.AbsentPathProbe,
                ObservedInputConstants.FileContentRead).FileOutput;

            XAssert.AreEqual(correctOut1, correctOut2);

            // Remove pipA's entry from the cache lookup store
            FingerprintStoreSession(ResultToStoreDirectory(build2, cacheLookupStore: true), store =>
            {
                store.RemoveFingerprintStoreEntryForTesting(pipAEntry);
            },
            readOnly: false);

            // Ensure that the analyzer falls-back on the execution-time store when the cache-lookup store is missing entries
            // srcB from pipB's dependencies will show up in the analysis because of earlier manipulation of the execution-time store
            var incorrectOut = RunAnalyzer(build1, build2).AssertAnalyzerPipMiss(
                pipA,
                PipCacheMissType.MissForDescriptorsDueToStrongFingerprints,
                ArtifactToPrint(srcB)).FileOutput;

            XAssert.AreNotEqual(correctOut2, incorrectOut);
        }

        /// <summary>
        /// Matches the string representation of <see cref="FileOrDirectoryArtifact"/> used by the fingerprint store
        /// when serializing to JSON.
        /// </summary>
        private string ArtifactToPrint(FileOrDirectoryArtifact artifact)
        {
            return Expander.ExpandPath(Context.PathTable, artifact.Path).ToLowerInvariant().Replace(@"\", @"\\");
        }

        public void AssertCacheMissEventLogged(params string[] requiredMessages)
        {
            if (Configuration.Logging.CacheMissAnalysisOption.Mode == CacheMissAnalysisOption.LocalMode().Mode)
            {
                var messages = requiredMessages.Select((s) => ObservedInputConstants.ToExpandedString(s));
                AssertLogContains(caseSensitive: false, requiredLogMessages: messages.ToArray());
            }
        }

        private string ResultToStoreDirectory(ScheduleRunResult result, bool cacheLookupStore = false)
        {
            return cacheLookupStore ? result.Config.Logging.CacheLookupFingerprintStoreLogDirectory.ToString(Context.PathTable) : result.Config.Logging.ExecutionFingerprintStoreLogDirectory.ToString(Context.PathTable);
        }

        /// <summary>
        /// Encapsulates one "session" with a fingerprint store.
        /// </summary>
        /// <param name="storeDirectory">
        /// Directory of the fingerprint store.
        /// </param>
        /// <param name="storeOps">
        /// The store operations to execute.
        /// </param>
        public static CounterCollection<FingerprintStoreCounters> FingerprintStoreSession(string storeDirectory, Action<FingerprintStore> storeOps, bool readOnly = true, FingerprintStoreTestHooks testHooks = null)
        {
            using (var fingerprintStore = FingerprintStore.Open(storeDirectory, readOnly: readOnly, testHooks: testHooks).Result)
            {
                storeOps(fingerprintStore);
                return fingerprintStore.Counters;
            }
        }
        protected override void Dispose(bool disposing)
        {
            CacheMissAnalyzerResultExtensions.FingerprintStoreAnalyzerTestsClass = null;
            base.Dispose(disposing);
        }
    }

    /// <summary>
    /// Extensions for BuildXL execution analyzers that perform cache miss analysis.
    /// </summary>
    public static class CacheMissAnalyzerResultExtensions
    {
        /// <summary>
        /// Provides an opportunity to do extra testing within the <see cref="FingerprintStoreAnalyzer"/> test class only.
        /// </summary>
        public static FingerprintStoreAnalyzerTests FingerprintStoreAnalyzerTestsClass = null;

        /// <summary>
        /// Checks <see cref="AnalyzerResult.FileOutput"/> for correct analysis on a pip cache miss.
        /// </summary>
        /// <param name="pip">The expected pip that had a miss.</param>
        /// <param name="missType">The expected <see cref="PipCacheMissType"/>.</param>
        /// <param name="messages">Expected messages to be printed.</param>
        /// <note>
        /// This is highly inefficient since it does a full pass over the 
        /// output file for every assertion.
        /// </note>
        public static AnalyzerResult AssertPipMiss(
            this AnalyzerResult result,
            Pip pip,
            PipCacheMissType missType,
            params string[] messages)
        {
            FingerprintStoreAnalyzerTestsClass?.AssertCacheMissEventLogged(messages);
            return AssertAnalyzerPipMiss(result, pip, missType, messages);
        }

        /// <summary>
        /// Checks <see cref="AnalyzerResult.FileOutput"/> for correct analysis on a pip cache miss.
        /// Only the file output of the execution analyzer executable is checked.
        /// Use <see cref="AssertPipMiss(AnalyzerResult, Pip, PipCacheMissType, string[])"/> to additionally
        /// test runtime cache miss analysis output.
        /// </summary>
        /// <param name="pip">The expected pip that had a miss.</param>
        /// <param name="missType">The expected <see cref="PipCacheMissType"/>.</param>
        /// <param name="messages">Expected messages to be printed.</param>
        /// <note>
        /// This is highly inefficient since it does a full pass over the 
        /// output file for every assertion.
        /// </note>
        public static AnalyzerResult AssertAnalyzerPipMiss(
            this AnalyzerResult result,
            Pip pip,
            PipCacheMissType missType,
            params string[] messages)
        {
            result.AssertSuccess();

            AssertAnalyzerOutput(result, pip.FormattedSemiStableHash, missType.ToString());
            return AssertAnalyzerOutput(result, messages);
        }

        /// <summary>
        /// Checks <see cref="AnalyzerResult.FileOutput"/> for certain strings.
        /// Only the file output of the execution analyzer executable is checked.
        /// Use <see cref="AssertPipMiss(AnalyzerResult, Pip, PipCacheMissType, string[])"/> to additionally
        /// test runtime cache miss analysis output.
        /// </summary>
        /// <note>
        /// This is highly inefficient since it does a full pass over the 
        /// output file for every assertion.
        /// </note>
        public static AnalyzerResult AssertAnalyzerOutput(
            this AnalyzerResult result,
            params string[] messages)
        {
            foreach (var message in messages)
            {
                XAssert.IsTrue(result.FileOutput.Contains(ObservedInputConstants.ToExpandedString(message)), "Expected message: \"{0}\" to appear in analyzer output: \"{1}\"", ObservedInputConstants.ToExpandedString(message), result.FileOutput);
            }

            return result;
        }
    }
}
